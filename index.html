<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Книга процессов</title>
    <style>
      body {
        display: flex;
        flex-direction: column;
        font-family: tahoma, Arial;
        font-size: 15px;
        color: #000;
        background-color: #fff;
        min-height: 100vh;
      }

      ol {
        counter-reset: item;
      }

      .level1-list {
        padding-left: 0;
      }

      .list__item {
        position: relative;
      }

      .list__item_text:before {
        content: counters(item, '.') ' ';
        counter-increment: item;
      }

      .header {
        display: flex;
        flex-direction: column;
        background-color: #f7f7ff;
        padding: 10px;
        text-align: center;
      }

      .link-download {
        margin-right: 40px;
        padding: 5px 10px;
        text-decoration: underline;
        color: limegreen;
        cursor: pointer;
      }

      .heading {
        font-size: 17px;
      }

      .main {
        flex: auto;
        display: grid;
        grid-template-columns: 2fr 5fr;
        grid-column-gap: 5px;
      }

      .aside {
        background-color: #f1f1f1;
      }

      .list {
        list-style: none;
      }

      .list__item_text {
        font-weight: 400;
        padding: 5px 30px 5px 60px;
        border-radius: 5px;
      }

      .list__item_text:not([contenteditable='true']):hover,
      .list__item_text:not([contenteditable='true']):focus {
        background-color: lime;
        cursor: default;
      }

      .list__item_text:active {
        opacity: 0.5;
      }

      .active {
        font-weight: 600;
      }

      .unfolded {
        background-color: #c1c1c1;
      }

      .visually-hidden {
        display: none;
      }

      .button {
        position: absolute;
        width: 15px;
        height: 15px;
        text-align: center;
        background-color: inherit;
        padding: 0;
        border: none;
      }

      .button:hover,
      .section_content__button:hover {
        cursor: pointer;
      }

      .button-add {
        left: 0;
        top: 4px;
        font-size: 20px;
      }

      .button-delete {
        left: 20px;
        top: 4px;
        font-size: 20px;
      }

      .button-edit {
        left: 40px;
        top: 7px;
        font-size: 17px;
      }

      .button-add-child {
        right: 10px;
        top: 4px;
        font-size: 20px;
      }

      .button:active,
      .section_content__button:active {
        opacity: 0.2;
      }

      .list__item_text[contenteditable='true'] {
        background-color: #fff;
        font-weight: 400;
        border-radius: 5px;
        border: 2px solid orange;
        outline: none;
      }

      .content {
        padding: 10px;
      }

      .content[contenteditable='true'] {
        outline: none;
      }
    </style>
  </head>

  <body>
    <header class="header">
      <div class="links">
        <a class="link-download link-download-editable removable"
        download = 'Редактируемый файл.html'
          >Загрузить с возможностью редактирования</a
        >
        <a class="link-download link-download-locked removable" 
        download = 'Файл для пользователя.html'
          >Загрузить без возможности редактирования</a
        >
      </div>
      <h1 class="heading">
        Книга процессов. Направление партнерских КЦ.
      </h1>
    </header>

    <main class="main">
      <aside class="aside">
        <ol class="list level1-list">
          <li id="1" class="level1-list__item list__item">
            <button class="removable button button-add visually-hidden">
              +
            </button>
            <button class="removable button button-edit visually-hidden">
              ✎
            </button>

            <h2
              class="level1-list__heading unfolded list__item_text editable active"
            >
              Тематика
            </h2>
            <button class="button button-add-child">+</button>
          </li>
        </ol>
      </aside>
      <section class="section_content">
        <button
          class="section_content__button-edit section_content__button removable"
        >
          ✎
        </button>
        <div class="content" id="1_content">
          Текст
        </div>
      </section>
    </main>

    <script>
      const statefulElements = document.getElementsByClassName(
        'list__item_text'
      );
      const editableElements = document.getElementsByClassName('editable');
      const buttons = document.getElementsByClassName('button');
      const hasTagChildren = (element, tag) =>
        [...element.children]
          .map(element => element.tagName.toLowerCase())
          .includes(tag);

      const siblingsArray = element => [...element.parentNode.children];

      const maxId = [...statefulElements].reduce(
        (acc, current) =>
          Number(current.parentNode.id) > acc
            ? Number(current.parentNode.id)
            : acc,
        0
      );

      const makeCounter = () => {
        let counter = maxId;
        return () => (counter = Number(counter) + 1);
      };

      const getMenuElementContentId = menuElement =>
        `${menuElement.parentNode.id}_content`;

      const makeId = makeCounter();
      const makeContentId = id => `${id}_content`;

      const toggleFoldedState = element => {
        if (element.parentNode.childElementCount === 5) {
          return;
        }
        if (element.contentEditable === 'true') {
          return;
        }
        element.classList.toggle('unfolded');
        element.parentNode.querySelector('list') &&
          element.parentNode
            .querySelector('list')
            .classList.toggle('visually-hidden');
      };

      const setEndOfContenteditable = contentEditableElement => {
        let range;
        let selection;

        range = document.createRange();
        range.selectNodeContents(contentEditableElement);
        range.collapse(false);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
      };

      const toggleButtonsVisibilityForElement = element => {
        const buttons = [...element.parentNode.children].filter(element =>
          element.classList.contains('button')
        );
        const isActive = element.classList.contains('active');
        buttons.forEach(button =>
          isActive
            ? button.classList.remove('visually-hidden')
            : button.classList.add('visually-hidden')
        );
      };

      const setActiveMenuElement = element => {
        const activeElement = document.querySelector('.active.list__item_text');

        activeElement && activeElement.classList.toggle('active');
        element.classList.toggle('active');
        toggleButtonsVisibilityForElement(element);
        activeElement && toggleButtonsVisibilityForElement(activeElement);
      };

      const setActiveContent = currentMenuElement => {
        const activeMenuElement = document.querySelector(
          '.active.list__item_text'
        );
        const activeMenuElementContent =
          activeMenuElement &&
          document.getElementById(getMenuElementContentId(activeMenuElement));
        const currentMenuElementContent = document.getElementById(
          getMenuElementContentId(currentMenuElement)
        );

        activeMenuElement &&
          activeMenuElementContent.classList.add('visually-hidden');
        activeMenuElementContent &&
          currentMenuElementContent.classList.remove('visually-hidden');
      };

      const setupSidebarNavigation = () =>
        [...statefulElements].forEach(
          element =>
            (element.onclick = () => handleOnClickElement(event.target))
        );

      setupSidebarNavigation();
      const handleOnClickElement = element => {
        setActiveContent(element);
        setActiveMenuElement(element);
        toggleFoldedState(element);
      };

      const deleteElement = element => {
        contentId = `${element.parentNode.id}_content`;
        element.parentNode.remove();
        document.getElementById(contentId).remove();
      };

      const makeElementEditable = element => {
        const setEditPossibility = isPossible => {
          if (isPossible) {
            element.contentEditable = true;
            element.focus();
            return;
          }
          element.contentEditable = false;
        };
        setEndOfContenteditable(element);
        setEditPossibility(true);
        element.onblur = () => setEditPossibility(false);
        element.onkeydown = event => {
          if (event.keyCode === 13) {
            setEditPossibility(false);
          }
        };
      };

      const makeElementsEditableOnButtonClick = buttons => {
        const editableElement = button =>
          siblingsArray(button).find(element =>
            element.classList.contains('editable')
          );
        buttons.forEach(
          button =>
            (button.onclick = event =>
              makeElementEditable(editableElement(event.target)))
        );
      };

      const setButtonsOnClickEvents = () => {
        const buttonsDeleteArray = [...buttons].filter(element =>
          element.classList.contains('button-delete')
        );
        const buttonsAddArray = [...buttons].filter(
          element =>
            element.classList.contains('button-add') ||
            element.classList.contains('button-add-child')
        );
        const buttonsEditArray = [...buttons].filter(element =>
          element.classList.contains('button-edit')
        );

        makeElementsEditableOnButtonClick(buttonsEditArray);
        buttonsDeleteArray.forEach(
          button => (button.onclick = event => window.confirm('Вы уверены, что хотите удалить элемент?') && deleteElement(event.target))
        );

        buttonsAddArray.forEach(
          button =>
            (button.onclick = event => {
              const parent = event.target.classList.contains('button-add-child')
                ? event.target.parentNode
                : event.target.parentNode.parentNode.parentNode;
              const newChildren = makeMenuElement(parent);
              const heading = [...parent.children].find(element =>
                element.classList.contains('list__item_text')
              );
              appendNewElement(parent, newChildren);
              const newContent = makeContent(newChildren.li);
              appendContent(newContent);
              heading &&
                !heading.classList.contains('unfolded') &&
                toggleFoldedState(heading);
              setupSidebarNavigation();
              setActiveContent(newChildren.heading);
              setActiveMenuElement(newChildren.heading);
              makeElementEditable(newChildren.heading);
            })
        );
      };

      setButtonsOnClickEvents();

      const makeMenuElement = parent => {
        const newElementListLevel = () => {
          if (parent.classList.contains('aside')) {
            return 1;
          } else if (parent.classList.contains('level1-list__item')) {
            return 2;
          }
          return 3;
        };

        const newListItemData = {
          tag: 'li',
          class: `level${newElementListLevel()}-list__item list__item`,
          content: ''
        };

        const newButtonsData = [
          {
            tag: 'button',
            class: 'button button-add removable',
            content: '+'
          },
          {
            tag: 'button',
            class: 'button button-delete removable',
            content: '✕'
          },
          {
            tag: 'button',
            class: 'button button-edit removable',
            content: '✎'
          },
          {
            tag: 'button',
            class: 'button button-add-child removable',
            content: '+'
          }
        ];

        const newHeadingData = {
          tag: `h${newElementListLevel() + 1}`,
          class: `level${newElementListLevel()}-list__heading list__item_text editable`,
          content: ''
        };

        const newOlData = {
          tag: 'ol',
          class: `list level${newElementListLevel()}-list`,
          content: ''
        };

        const makeElement = elementData => {
          newElement = document.createElement(elementData.tag);
          if (elementData.tag === 'li') {
            newElement.setAttribute('id', makeId());
          }
          newElement.setAttribute('class', elementData.class);
          newElement.innerHTML = elementData.content;
          if (newElement.tag === 'h2' || newElement.tag) {
            newElement.setAttribute('contenteditable', true);
          }

          return newElement;
        };

        const newOl = !hasTagChildren(parent, 'ol') && makeElement(newOlData);
        const newListItem = makeElement(newListItemData);
        const newHeading = makeElement(newHeadingData);
        const newButtons = newButtonsData.map(buttonData =>
          makeElement(buttonData)
        );

        return {
          ol: !hasTagChildren(parent, 'ol') && newOl,
          li: newListItem,
          heading: newHeading,
          buttons: newButtons
        };
      };

      const appendNewElement = (parent, newChildren) => {
        const existingOl = [...parent.children].find(child =>
          child.classList.contains('list')
        );
        const ol = hasTagChildren(parent, 'ol') ? existingOl : newChildren.ol;
        const li = ol.appendChild(newChildren.li);
        newChildren.buttons.forEach(button => li.appendChild(button));
        li.appendChild(newChildren.heading);
        ol.appendChild(li);
        if (!hasTagChildren(parent, 'ol')) {
          parent.appendChild(ol);
        }
        setButtonsOnClickEvents();
        newChildren.heading.focus();
      };

      const makeContent = menuElement => {
        const newElement = document.createElement('div');
        newElement.classList.add('content');
        newElement.setAttribute('id', `${menuElement.id}_content`);
        return newElement;
      };

      const appendContent = content =>
        document.querySelector('.section_content').appendChild(content);

      const buttonEditContent = document.querySelector(
        '.section_content__button-edit'
      );

      editContent = () => {
        const visibleContent = [
          ...document.getElementsByClassName('content')
        ].find(element => !element.classList.contains('visually-hidden'));
        if (visibleContent) {
          visibleContent.contentEditable = 'true';
        }
        setEndOfContenteditable(visibleContent);
        visibleContent.focus();
        visibleContent.addEventListener(
          'onblur',
          event => (event.target.contentEditable = 'false')
        );
      };

      buttonEditContent.onclick = () => editContent();

      const linkDownloadEditable = document.querySelector(
        '.link-download-editable'
      );
      const linkDownloadLocked = document.querySelector(
        '.link-download-locked'
      );

      linkDownloadLocked.onclick = function() {
        const clone = document.querySelector('html').cloneNode(true);
        const removableElements = clone.getElementsByClassName('removable');
        [...removableElements].forEach(element => element.remove());
        this.href =
        'data: application/html;charset=utf-8,' +
          encodeURIComponent(clone.innerHTML);
      };

      linkDownloadEditable.onclick = function() {
        const clone = document.querySelector('html').cloneNode(true);
        this.href =
          'data: application/html;charset=utf-8,' +
          encodeURIComponent(clone.innerHTML);
      };
    </script>
  </body>
</html>
